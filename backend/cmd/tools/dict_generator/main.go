// cmd/tools/dict_generator/main.go
package main

import (
	"fmt"
	"log"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"time"

	"github.com/gbrayhan/microservices-go/src/domain/constants"
	dictionaryRepo "github.com/gbrayhan/microservices-go/src/infrastructure/repository/psql/sys/dictionary"
	"github.com/gbrayhan/microservices-go/src/shared/utils"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
)

// DictConstant 用于生成常量的结构
type DictConstant struct {
	TypeName    string             // 字典类型名
	Description string             // 字典描述
	Items       []DictConstantItem // 字典项
}

// DictConstantItem 字典项常量
type DictConstantItem struct {
	ConstantName string // 常量名 (Type+Extend)
	Value        string // 常量值 (Value)
	Label        string // 标签名
	Extend       string // 扩展值
}

func main() {
	// load config.yaml
	if err := utils.LoadYAMLConfigToEnv(); err != nil {
		log.Fatal(fmt.Errorf("error loading config.yaml: %w", err))
	}

	// 数据库连接
	dsn := os.Getenv("DICT_DB_DSN")
	if dsn == "" {
		log.Fatal("DICT_DB_DSN environment variable is required")
	}

	// 验证和清理 DSN
	cleanedDSN := cleanDSN(dsn)
	fmt.Printf("Connecting to database with DSN: %s\n", maskPassword(cleanedDSN))

	db, err := gorm.Open(postgres.Open(cleanedDSN), &gorm.Config{})
	if err != nil {
		log.Fatalf("failed to connect database: %v", err)
	}

	// 读取字典数据
	dictConstants, err := fetchDictionaryData(db)
	if err != nil {
		log.Fatalf("failed to fetch dictionary data: %v", err)
	}

	// 生成常量文件
	if err := generateConstantsFilesByType(dictConstants); err != nil {
		log.Fatalf("failed to generate constants files: %v", err)
	}

	fmt.Println("Dictionary constants generated successfully!")
}

// 清理和验证 DSN
func cleanDSN(dsn string) string {
	// 如果是完整的 URL 格式，直接返回
	if strings.HasPrefix(dsn, "postgres://") || strings.HasPrefix(dsn, "postgresql://") {
		return dsn
	}

	// 如果是键值对格式，转换为 URL 格式
	if strings.Contains(dsn, "=") && strings.Contains(dsn, "host") {
		// 已经是正确的格式
		return dsn
	}

	return dsn
}

// 隐藏密码用于日志输出
func maskPassword(dsn string) string {
	if strings.HasPrefix(dsn, "postgres://") || strings.HasPrefix(dsn, "postgresql://") {
		u, err := url.Parse(dsn)
		if err == nil {
			if u.User != nil {
				u.User = url.UserPassword(u.User.Username(), "***")
				return u.String()
			}
		}
	}
	return dsn
}
func fetchDictionaryData(db *gorm.DB) ([]DictConstant, error) {
	var dictionaries []dictionaryRepo.SysDictionary

	// 预加载字典详情
	err := db.Preload("Details", func(db *gorm.DB) *gorm.DB {
		return db.Where("status = ?", constants.StatusEnabled).Order("sort")
	}).Where("status = ? and is_generate_file = ?", constants.StatusEnabled, 1).
		Find(&dictionaries).Error

	if err != nil {
		return nil, fmt.Errorf("failed to query dictionaries: %w", err)
	}

	var dictConstants []DictConstant
	for _, dict := range dictionaries {
		constant := DictConstant{
			TypeName:    dict.Type,
			Description: dict.Desc,
			Items:       make([]DictConstantItem, 0, len(dict.Details)),
		}

		for _, detail := range dict.Details {
			item := DictConstantItem{
				ConstantName: formatConstantName(dict.Type, detail.Extend),
				Value:        detail.Value,
				Label:        detail.Label,
				Extend:       detail.Extend,
			}

			constant.Items = append(constant.Items, item)
		}

		if len(constant.Items) > 0 {
			dictConstants = append(dictConstants, constant)
		}
	}

	return dictConstants, nil
}

func formatConstantName(dictType, extend string) string {
	// 格式化为合法的Go常量名
	// 例如: USER_STATUS + ACTIVE = UserStatusActive

	// 处理字典类型
	typeParts := strings.Split(strings.ToUpper(dictType), "_")
	formattedType := ""
	for _, part := range typeParts {
		if part != "" {
			formattedType += strings.Title(strings.ToLower(part))
		}
	}

	// 处理扩展值
	extendParts := strings.Split(strings.ToUpper(extend), "_")
	formattedExtend := ""
	for _, part := range extendParts {
		if part != "" {
			formattedExtend += strings.Title(strings.ToLower(part))
		}
	}

	return formattedType + formattedExtend
}

// 根据字典类型确定生成文件的目录
func getOutputDirForDictType(dictType string) string {
	// 根据字典类型前缀决定输出目录
	switch {
	case strings.HasPrefix(dictType, "api_"):
		return "src/domain/sys/api/constants"
	case strings.HasPrefix(dictType, "task_"):
		return "src/domain/sys/scheduled_task/constants"
	case strings.HasPrefix(dictType, "file_"):
		return "src/domain/sys/files/constants"
	case strings.HasPrefix(dictType, "zap_"):
		return "src/domain/sys/operation_records/constants"
	default:
		// 默认目录
		return "src/domain/constants"
	}
}

// 获取包名
func getPackageNameForDir(dir string) string {
	parts := strings.Split(dir, "/")
	if len(parts) > 0 {
		return parts[len(parts)-1]
	}
	return "dictionary"
}

// 为单个字典生成常量文件
func generateSingleConstantFile(dictConstant DictConstant, outputPath string) error {
	tmpl := `// Code generated by go generate; DO NOT EDIT.
// Generated at: {{.Timestamp}}
// Dictionary type: {{.Dictionary.TypeName}}

package {{.PackageName}}

{{- if .Dictionary.Description}}
// {{.Dictionary.TypeName}} - {{.Dictionary.Description}}
{{- else}}
// {{.Dictionary.TypeName}} constants
{{- end}}
const (
{{- range .Dictionary.Items}}
	{{.ConstantName}} = "{{.Value}}" // {{.Label}}
{{- end}}
)

// {{.TypeName}}LabelMap label mapping for {{.TypeName}}
var {{.TypeName}}LabelMap = map[string]string{
{{- range .Dictionary.Items}}
	{{.ConstantName}}: "{{.Label}}",
{{- end}}
}

// {{.TypeName}}Options all options for {{.TypeName}}
var {{.TypeName}}Options = []struct{
	Value string
	Label string
}{
{{- range .Dictionary.Items}}
	{ {{.ConstantName}}, "{{.Label}}" },
{{- end}}
}
`

	type TemplateData struct {
		Timestamp   string
		PackageName string
		TypeName    string
		Dictionary  DictConstant
	}

	data := TemplateData{
		Timestamp:   time.Now().Format("2006-01-02 15:04:05"),
		PackageName: getPackageNameForDir(filepath.Dir(outputPath)),
		TypeName:    dictConstant.TypeName,
		Dictionary:  dictConstant,
	}

	// 确保目录存在
	dir := filepath.Dir(outputPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory %s: %w", dir, err)
	}

	file, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to create constants file %s: %w", outputPath, err)
	}
	defer file.Close()

	t, err := template.New("constants").Parse(tmpl)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	if err := t.Execute(file, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return nil
}

// 按类型分组生成常量文件
func generateConstantsFilesByType(dictConstants []DictConstant) error {
	for _, dictConstant := range dictConstants {
		// 确定输出目录
		outputDir := getOutputDirForDictType(dictConstant.TypeName)

		// 构造文件路径
		filename := fmt.Sprintf("%s.go", strings.ToLower(dictConstant.TypeName))
		outputPath := filepath.Join(outputDir, filename)

		// 生成单个文件
		if err := generateSingleConstantFile(dictConstant, outputPath); err != nil {
			return fmt.Errorf("failed to generate constants for %s: %w", dictConstant.TypeName, err)
		}

		fmt.Printf("Generated constants for %s at %s\n", dictConstant.TypeName, outputPath)
	}

	return nil
}
